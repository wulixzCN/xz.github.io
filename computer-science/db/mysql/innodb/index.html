<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/xz.github.io/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/xz.github.io/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="My Blog" href="https://wulixzcn.github.io/xz.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="My Blog" href="https://wulixzcn.github.io/xz.github.io/atom.xml"><link rel="alternate" type="application/json" title="My Blog" href="https://wulixzcn.github.io/xz.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/xz.github.io/css/app.css?v=0.2.5"><meta name="keywords" content="笔记,DB"><link rel="canonical" href="https://wulixzcn.github.io/xz.github.io/computer-science/db/mysql/innodb/"><title>InnoDB存储引擎 - db - 计算机科学 | Cloud = My Blog = You Want Some, Come Get Some</title><meta name="generator" content="Hexo 6.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">InnoDB存储引擎</h1><div class="meta"><span class="item" title="创建时间：2022-02-25 15:02:03"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-02-25T15:02:03+08:00">2022-02-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/xz.github.io/" rel="start">Cloud</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipet8c1a2j20zk0m8kct.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicli9lfebj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipevuctzzj20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/xz.github.io/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/xz.github.io/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/xz.github.io/categories/computer-science/db/" itemprop="item" rel="index" title="分类于 db"><span itemprop="name">db</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wulixzcn.github.io/xz.github.io/computer-science/db/mysql/innodb/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/xz.github.io/images/avatar.jpg"><meta itemprop="name" content="梦想稻草"><meta itemprop="description" content="You Want Some, Come Get Some, 分享"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Blog"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>本篇文章是针对于 <code>InnoDB存储引擎</code> 的阅读笔记。</p><p>理解数据库的存储引擎可以更好地了解数据库运行的原理、索引算法、事务以及性能调优等。</p><p>本文 主要是阅读 <code>《MySQL技术内幕: InnoDB存储引擎》</code> 所做的笔记。</p><p>如果想亲自阅读的童鞋，这里附录了本书的 PDF 链接: <span class="exturl" data-url="aHR0cHM6Ly9hd2Vzb21lLXByb2dyYW1taW5nLWJvb2tzLmdpdGh1Yi5pby9teXNxbC9NeVNRTCVFNiU4QSU4MCVFNiU5QyVBRiVFNSU4NiU4NSVFNSVCOSU5NSVFRiVCQyU5QUlubm9EQiVFNSVBRCU5OCVFNSU4MiVBOCVFNSVCQyU5NSVFNiU5MyU4RS5wZGY=">《MySQL 技术内幕: InnoDB 存储引擎》</span></p></div><h1 id="第一章-mysql体系结构和存储引擎"><a class="anchor" href="#第一章-mysql体系结构和存储引擎">#</a> 第一章 MySQL 体系结构和存储引擎</h1><h2 id="定义数据库和实例"><a class="anchor" href="#定义数据库和实例">#</a> 定义数据库和实例</h2><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre>MySQL 是一个单进程多线程架构的数据库<span class="token punctuation">,</span>类似的有SQL Server、 Oracle Windows版</pre></td></tr></table></figure><div class="note info"><p><strong>什么是数据库？</strong> 物理操作系统文件或其他形式文件类型的结合<br><strong>什么是数据库实例？</strong> 由数据库后台进程 / 线程以及一个共享内存区组成</p></div><h2 id="mysql体系结构"><a class="anchor" href="#mysql体系结构">#</a> Mysql 体系结构</h2><p><img data-src="../../../../images/mysql_architect.png" alt="&quot;图1-1 Mysql体系结构&quot;" title="图1-1 Mysql体系结构"></p><p>如图 1-1 所示，MySQL 由以下几个部门组成</p><blockquote><ol><li>链接池组件</li><li>管理服务和工具组件</li><li>SQL 接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲 (Cache) 组件</li><li>插件式存储引擎</li><li>物理文件</li></ol></blockquote><blockquote><p><strong>存储引擎是基于表的，而不是数据库</strong></p></blockquote><h2 id="mysql表存储引擎"><a class="anchor" href="#mysql表存储引擎">#</a> MySQL 表存储引擎</h2><p><a href="innodb_eng/">InnoDB 存储引擎</a><br><a href="myisam_eng/">MyISAM 存储引擎</a></p><hr><h1 id="第二章-innodb存储引擎"><a class="anchor" href="#第二章-innodb存储引擎">#</a> 第二章 InnoDB 存储引擎</h1><h2 id="innodb-体系架构"><a class="anchor" href="#innodb-体系架构">#</a> InnoDB 体系架构</h2><h3 id="后台线程"><a class="anchor" href="#后台线程">#</a> 后台线程</h3><p>默认情况下，InnoDB 存储引擎的后台线程有 7 个</p><blockquote><p>4 个 IO 线程 [分别是 insert buffer thread, log thread, read thread, write thread]<br>1 个 master thread<br>1 个锁 (lock) 监控线程<br>1 个错误监控线程<br>InnoDB 引擎在 <strong><code>master thread 上</code> </strong>几乎实现了所有功能</p></blockquote><h3 id="内存"><a class="anchor" href="#内存">#</a> 内存</h3><p>InnoDB 存储引擎 <code>内存</code> 由以下几个部分组成。</p><blockquote><p><strong>缓冲池</strong> (buffer pool)<br><strong>重做日志缓冲池</strong> (redo log buffer)<br><strong>额外内存池</strong> (additional memory pool)</p></blockquote><p><img data-src="../../../../images/memory_architect.png" alt="&quot;图2-1 InnoDB存储引擎内存结构&quot;" title="图2-1 InnoDB存储引擎内存结构"></p><div class="note info"><p>缓冲池是占最大内存的部分，用来存放各种数据的缓存<br><code>InnoDB存储引擎</code> 的工作方式是<strong>将数据库文件按 <code>页</code> (每页 16K) 读取到缓冲池</strong>，然后按 <code>最近最少使用(LRU)</code> 算法来保存在缓冲池中的缓存数据</p></div><blockquote><p><strong>什么是脏页</strong>？数据库文件需要修改时，先修改在缓冲池中的页。 发生修改后，该页即为 <code>脏页</code> 。</p></blockquote><h2 id="master-thread"><a class="anchor" href="#master-thread">#</a> master thread</h2><p>master thread 的线程优先级最高，其由以下 4 个循环 (loop) 组成:</p><blockquote><ol><li>主循环 (loop)</li><li>后台循环 (background loop)</li><li>刷新循环 (flush loop)</li><li>暂停循环 (suspend loop)</li></ol></blockquote><p>master thread 会根据数据库运行的状态在这几个循环中进行切换</p><h3 id="自适应哈希索引"><a class="anchor" href="#自适应哈希索引">#</a> 自适应哈希索引</h3><p><code>InnoDB存储引擎</code> 会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度上的提升，则建立哈希索引 (所以称为自适应的).<br>自适应哈希索引通过缓冲池的 B + 树构造而来，因此建立的速度很快。<br>而且不需要将整个表都建哈希索引， <code>InnoDB存储引擎</code> 引擎会自动根据访问的频率和模式来为某些页建立哈希索引。</p><div class="note info"><p><strong>哈希索引只能用来搜索等值的查询，对于如范围查找，是不能使用的。</strong></p></div><hr><h1 id="第四章-表"><a class="anchor" href="#第四章-表">#</a> 第四章 表</h1><p>简单的说，表就是关于特定实体的数据集合，这也是关系型数据库模型的核心<br>在 <code>InnoDB存储引擎</code> 表中，每张表都有个主键，如果在创建表时没有显式地定义主键 (Primary Key), 则 <code>InnoDB存储引擎</code> 会按如下方式选择或创建主键:</p><blockquote><ol><li>先看表中是否有非空的 <code>唯一索引(Unique NOT NULL)</code> , 如果有，则该列即为主键。</li><li>不符合上述条件， <code>InnoDB存储引擎</code> 会自动创建一个 <strong>6 个字节</strong> 大小的指针。</li></ol></blockquote><h2 id="innodb逻辑存储结构"><a class="anchor" href="#innodb逻辑存储结构">#</a> InnoDB 逻辑存储结构</h2><p><code>InnoDB存储引擎</code> 所有的数据都被逻辑地存放在一个空间中 --- <strong><code>表空间</code></strong><br><code>表空间</code> 又由 <code>段(segment)</code> , <code>区(extent)</code> , <code>页(page)</code> 组成.(页有时也被称为 <code>块block</code> )</p><p><img data-src="../../../../images/innodb_store_structure.png" alt="&quot;图4-1 InnoDB存储引擎的逻辑存储结构&quot;" title="图4-1 InnoDB存储引擎的逻辑存储结构"></p><h3 id="段segment"><a class="anchor" href="#段segment">#</a> 段 (segment)</h3><p>图 4-1 显示了表空间由各个段组成。常见的有 <code>数据段</code> ， <code>索引段</code> ， <code>回滚段</code> 等。<br><code>数据段</code> 即为 B + 树的叶子节点 (leaf node segment), <code>索引段</code> 即为 B + 树的非叶子节点 (non-leaf node segment)</p><h3 id="区extent"><a class="anchor" href="#区extent">#</a> 区 (extent)</h3><p>区是由 64 个 连续的页组成，每个页大小为 16KB, 即每个区的大小为 1MB。<br>对于大的数据段， <code>InnoDB存储引擎</code> 最多每次可以申请 4 个区，以此来保证数据的顺序性能。</p><h3 id="页page-块block"><a class="anchor" href="#页page-块block">#</a> 页 (page) / 块 (block)</h3><p>页时 InnoDB 磁盘管理的最小单位，每个页大小为 16KB。<br>常见的页类型有:</p><blockquote><ol><li>数据页 (B-tree Node)</li><li>Undo 页 (Undo Log Page)</li><li>系统页 (System Page)</li><li>事务数据页 (Transaction system Page)</li><li>插入缓冲位图页 (Insert Buffer Bitmap)</li><li>插入缓冲空闲列表页 (Insert Buffer Free List)</li><li>未压缩的二进制大对象页 (Uncompressed BLOB Page)</li><li>压缩的二进制大对象页 (Compressed BLOB Page)</li></ol></blockquote><h3 id="行"><a class="anchor" href="#行">#</a> 行</h3><p><code>InnoDB存储引擎</code> 是面向 <code>行</code> 的 (row-oriented), 数据的存放按 <code>行</code> 进行存放。<br>每个页存放的行记录是 hard-coding 的，最多允许存放 (16 * 1024B / 2) - 200 行的记录，即 7992 行记录。<br>计算方式：每页大小为 16KB, 每个记录最少 2 字节，每个页都要预留 200 字节。<br>解释：这两行记录是虚拟记录，用来限定记录的边界，最大虚拟记录和最小虚拟记录</p><h2 id="约束"><a class="anchor" href="#约束">#</a> 约束</h2><h3 id="数据完整性"><a class="anchor" href="#数据完整性">#</a> 数据完整性</h3><p>数据完整性有三种形式</p><blockquote><ol><li>实体完整性：保证表中有一个主键</li><li>域完整性：保证数据的值满足特定的条件 (如，选择合适的数据类型可以确保一个数据值满足特定条件)</li><li>参照完整性：保证两张表之间的关系</li></ol></blockquote><p><code>InnoDB存储引擎</code> 提供以下几种约束</p><blockquote><ol><li>Primary Key</li><li>Unique Key</li><li>Foreign Key</li><li>Default</li><li>NOT NULL</li></ol></blockquote><h3 id="约束和索引的区别"><a class="anchor" href="#约束和索引的区别">#</a> 约束和索引的区别</h3><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>当创建一个唯一索引时，也就创建了一个唯一的约束。</pre></td></tr><tr><td data-num="2"></td><td><pre> 但是约束和索引的概念不同，约束更是一个逻辑的概念，用来保证数据完整性。而索引是一个数据结构，有逻辑上的概念，在数据库中更是一个物理存储方式</pre></td></tr></table></figure><h2 id="视图"><a class="anchor" href="#视图">#</a> 视图</h2><blockquote><p>视图是一个命名的虚表，它由一个查询来定义，可以当作表使用，但视图中的数据没有物理变现形式。</p></blockquote><hr><h1 id="第五章-索引与算法"><a class="anchor" href="#第五章-索引与算法">#</a> 第五章 索引与算法</h1><p><code>InnoDB存储引擎</code> 支持常见的两种索引：B + 树索引和哈希索引。<br>B + 树索引的 B 不是代表二叉 (binary), 而是代表平衡 (balance)。<br>B + 树从最早的平衡二叉树演化而来，但是 B + 树不是一个二叉树。</p><div class="note info"><p>B + 树索引并不能找到一个给定键值的具体 <code>行</code> ，而只能找到被查找数据行所在的 <code>页</code> 。<br>然后数据库通过把 <code>页</code> 读入 <code>内存</code> ，再在 <code>内存</code> 中进行查找，最后得到要查找的数据。</p></div><h2 id="b树"><a class="anchor" href="#b树">#</a> B + 树</h2><blockquote><ol><li>非叶子节点不存储 Data, 只存储索引 (冗余), 可以放更多的索引。 (索引 <code>块</code> / <code>页</code> 内存 16KB ，其中地址块 6B)</li><li>叶子节点包含所有索引字段</li><li>叶子节点用指针连接 (双向指针), 提高区间访问的性能</li></ol></blockquote><h2 id="b树索引"><a class="anchor" href="#b树索引">#</a> B + 树索引</h2><p>数据库中的 B + 树索引可以分为聚集索引 (clustered index) 和辅助聚集索引 (secondary index). 其内部都是 B + 树的，即高度平衡的，叶子节点存放着所有的数据。<br>聚集索引和非聚集索引的不同是：聚集索引的叶子节点存放的是一整行的信息。</p><h3 id="聚集索引"><a class="anchor" href="#聚集索引">#</a> 聚集索引</h3><blockquote><p><code>InnoDB存储引擎</code> 是索引组织表，即表中数据按照主键顺序存放。<br>聚集索引就是按照每张表的主键构造一颗 B + 树，并且叶子节点中存放着整张表的行记录数据，因此也让聚集索引的叶子节点成为数据页。<br>由于实际的数据页只能按照一颗 B + 树进行排序，因此每张表只能有一个聚集索引。</p></blockquote><blockquote><p>聚集索引的存储并不是物理上的连续，是逻辑上的连续。</p><ol><li>页通过双向链表连接，页按照主键的顺序排列。</li><li>每个页中的记录也是通过双向链表进行维护。</li></ol></blockquote><h3 id="辅助索引"><a class="anchor" href="#辅助索引">#</a> 辅助索引</h3><p>对于辅助索引 (也称非聚集索引)，叶级别不包含行的全部数据。<br>叶节点除了包含用来排序的 key 以外，每个叶级别中的索引行还包含了一个书签 (bookmark)，该书签用来告诉 InnoDB 存储引擎好到与索引对应的行数据。</p><h2 id="b树索引的使用"><a class="anchor" href="#b树索引的使用">#</a> B + 树索引的使用</h2><h3 id="什么时候用-b树索引"><a class="anchor" href="#什么时候用-b树索引">#</a> 什么时候用 B + 树索引</h3><p>当访问高选择性字段并从表中取出很少一部分行时，对这个字段添加 B + 树索引是非常有必要的。</p><h3 id="顺序读-随机读和预读取"><a class="anchor" href="#顺序读-随机读和预读取">#</a> 顺序读、随机读和预读取</h3><h3 id="辅助索引的优化使用"><a class="anchor" href="#辅助索引的优化使用">#</a> 辅助索引的优化使用</h3><p>辅助索引的叶节点包含有主键，但是辅助索引的叶并不包含完整的行信息。<br>因此 <code>InnoDB存储引擎</code> 总是会先从辅助索引的叶节点判断是否能得到所需的数据。</p><h3 id="联合索引"><a class="anchor" href="#联合索引">#</a> 联合索引</h3><p>联合索引是指对表上的多个列做索引。<br>从本质来说，联合索引还是一个 B + 树，只是键值的数量不是 1，而是大于等于 2</p><div class="note info"><p>最左前缀原则<br>联合索引按照这个原则才能走索引</p></div><h2 id="哈希算法"><a class="anchor" href="#哈希算法">#</a> 哈希算法</h2><p><code>InnoDB存储引擎</code> 中自适应哈希索引使用的是散列表 (Hash Table) 的数据结构。<br>散列表不止存在于自适应哈希中，在每个数据库中都存在。</p><p>数据库中一般采用 链接法 (chaining) 解决 Hash 碰撞，哈希函数采用 除法散列方式: h (k) = k mod m</p><h1 id="锁"><a class="anchor" href="#锁">#</a> 锁</h1><p>锁是数据库系统区别于文件系统的一个关键特征。锁机制用于管理对共享资源的并发访问。<br>对于 <code>MyISAM引擎</code> 来说，其锁就是表锁。并发插入时性能会差点。</p><h2 id="innodb存储引擎中的锁"><a class="anchor" href="#innodb存储引擎中的锁">#</a> InnoDB 存储引擎中的锁</h2><h3 id="锁的类型"><a class="anchor" href="#锁的类型">#</a> 锁的类型</h3><p><code>InnoDB存储引擎</code> 实现了如下两种标准的行级锁:</p><blockquote><ol><li>共享锁 (S Lock)，允许事务读一行数据。</li><li>排他锁 (X Lock)，允许事务删除或更新一行数据。<br><code>InnoDB存储引擎</code> 支持多粒度锁定，这种锁定允许在行级上的锁和表级上的锁同时存在。<br>为了支持在不同粒度上进行加锁操作， <code>InnoDB存储引擎</code> 支持一种额外的锁方式：意向锁。<br><code>意向锁</code> 是表级别的锁，目的是为了在一个事务中揭示下一行将被请求的锁的类型。目前支持两种意向锁：</li><li>意向共享锁 (IS Lock)，事务想要获得一个表中某几行的共享锁。</li><li>意向排他锁 (IX Lock)，事务想要获取一个表中某几行的排他锁。</li></ol></blockquote><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>举个例子：</pre></td></tr><tr><td data-num="2"></td><td><pre>事务A锁住了表中的一行，让这一行只能读，不能写</pre></td></tr><tr><td data-num="3"></td><td><pre>之后，事务B申请整个表的写锁。</pre></td></tr><tr><td data-num="4"></td><td><pre>这是数据库要判断:</pre></td></tr><tr><td data-num="5"></td><td><pre>step1：判断表是否已被其他事务用表锁锁表</pre></td></tr><tr><td data-num="6"></td><td><pre>step2：判断表中的每一行是否已被行锁锁住。</pre></td></tr><tr><td data-num="7"></td><td><pre>当执行step2的时候需要扫全表，显然效率过低。</pre></td></tr><tr><td data-num="8"></td><td><pre>这时就有个意向锁。 事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。</pre></td></tr></table></figure><h3 id="一致性的非锁定读操作"><a class="anchor" href="#一致性的非锁定读操作">#</a> 一致性的非锁定读操作</h3><p>在默认情况下， <code>InnoDB存储引擎</code> 的 Select 操作使用一致性非锁定读。<br>一致性的非锁定行读 (consistent nonlocking read) 是指 <code>InnoDB存储引擎</code> 通过 <code>行多版本控制</code> (multi versioning) 的方式来读取当前执行时间数据库中行的数据。<br>如果读取的行正在执行 Delete、Update 操作，这时读取操作不会因此而会等待行上锁的释放。相反， <code>InnoDB存储引擎</code> 会去读取行的一个 <code>快照数据</code> 。<br><code>快照数据</code> 是指该行之前版本的数据，该实现是通过 Undo 段来实现的。而 Undo 用来在事务中回滚数据，因此快照数据本身是没有额外的开销。</p><div class="note info"><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。<br>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。<br>与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p></div><p>快照数据是当前行数据之前的历史版本，可能有多个版本，一行可能不止一个快照数据，所以称其为 <code>行多版本技术</code> 。<br>由此带来的并发控制，称之为 <code>多版本并发控制</code> (Multi Version Concurrency Control, MVCC)</p><h4 id="快照读"><a class="anchor" href="#快照读">#</a> 快照读</h4><p><code>MVCC</code> 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p><pre><code class="language-mysql">SELECT * FROM table ...;
</code></pre><h4 id="当前读"><a class="anchor" href="#当前读">#</a> 当前读</h4><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><pre><code class="language-mysql">INSERT;
UPDATE;
DELETE;
</code></pre><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。<br>(这两个操作必须在一个事务中，当事务提交了，锁也释放了)</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span> <span class="token comment"># 对行记录加一个 S 锁，其他事务可以向被锁定的记录加 S 锁，但对于加 X 锁，则会被阻塞。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> ? <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span class="token comment"># 对读取的行记录加上一个 X 锁，其他事物想在这些行上加任何锁时都会被阻塞。</span></pre></td></tr></table></figure><h2 id="锁的算法"><a class="anchor" href="#锁的算法">#</a> 锁的算法</h2><p><code>InnoDB存储引擎</code> 有 3 个行锁的算法设计，分别是</p><blockquote><ol><li>Record Lock: 单个行记录上的锁。(锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用)</li><li>Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock: Gap Lock + Record Lock, 锁定一个范围，并且锁定记录本身</li></ol></blockquote><p>在 Repeatable Read 模式下，Next-Key Lock 算法是默认的行记录锁定算法。</p><h2 id="锁问题"><a class="anchor" href="#锁问题">#</a> 锁问题</h2><h3 id="丢失修改"><a class="anchor" href="#丢失修改">#</a> 丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><blockquote><p>顾名思义即，我修改了一个字段的值，当修改完成我 select 时，发现当前值不是我修改的值，即丢失修改。</p></blockquote><h3 id="读脏数据"><a class="anchor" href="#读脏数据">#</a> 读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><blockquote><p>比如，简单说就是我读到了别人的 draft 数据，该数据后又被撤销了。</p></blockquote><h3 id="不可重复读"><a class="anchor" href="#不可重复读">#</a> 不可重复读</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><blockquote><p>比如，即我在一个事务内 多次读取一个数据，多次读取的不一致。</p></blockquote><div class="note info"><p>不可重复读和脏读的区别是： 脏读是读到未提交的数据。不可重复读 读到的确实是已经提交的数据，但是其违反了数据库事务一致性的要求。</p></div><p><code>InnoDB存储引擎</code> 中，通过使用 Next-Key Lock 算法来避免不可重复读的问题。在 MySQL 官方文档中，将不可重复读定义为 Phantom Problem，即幻读问题。<br>在 Next-Key Lock 算法下，对于索引的扫描，不仅仅是锁住扫描的索引，还锁住这些索引覆盖的范围 (gap)<br>因此对这个范围内的插入都是不允许的，这样就避免了另外的事务在这个范围内插入数据导致的不可重复的问题。</p><h2 id="死锁"><a class="anchor" href="#死锁">#</a> 死锁</h2><p><code>InnoDB存储引擎</code> 的后台线程中有一个锁 (lock) 监控线程，该线程负责查看可能的死锁问题，并字段告知用户。<br><code>InnoDB存储引擎</code> 不会回滚大部分的错误异常，但是死锁除外。发现死锁后， <code>InnoDB存储引擎</code> 会马上回滚一个事务。</p><h1 id="事务"><a class="anchor" href="#事务">#</a> 事务</h1><p>事务用来保证数据库的完整性 ---- 要么都修改，要么都不做<br><code>InnoDB存储引擎</code> 中的事务完全符合 ACID 的特性</p><blockquote><ol><li>原子性 (Atomicity) 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</li><li>一致性 (Consistency) 事务将 DB 从一种状态变为下一种一致的状态。事务开始和结束，DB 的完整性约束没有被破坏。</li><li>隔离性 (Isolation) 一个事务的影响在该事务提交前对其他事务不可见。 ---- 通过锁来实现</li><li>持久性 (Durability)</li></ol></blockquote><h2 id="事务的实现"><a class="anchor" href="#事务的实现">#</a> 事务的实现</h2><p>隔离性由 <code>锁</code> 来实现，原子性、一致性、持久性通过数据库的 redo 和 undo 来完成。</p><h3 id="redo"><a class="anchor" href="#redo">#</a> redo</h3><p><code>InnoDB存储引擎</code> 中，事务日志通过重做 (redo) 日志文件和 <code>InnoDB存储引擎</code> 的日志缓冲 (InnoDB Log Buffer) 来实现。</p><ol><li>当一个事务开始时，会记录该事务的一个 LSN (Log Sequence Number, 日志序列号)</li><li>当事务执行时，会往 <code>InnoDB存储引擎</code> 的日志缓冲里插入 <code>事务日志</code> 。</li><li>当事务提交时，必须将 <code>InnoDB存储引擎</code> 的 <code>日志</code> 缓冲写入磁盘。也就是在写数据之前，要先写日志。这种方式称为预写日志方式 (Write-Ahead Logging, WAL)<br><code>InnoDB存储引擎</code> 通过预写日志的方式来保证事务的完整性。<br>这意味着磁盘上存储的 <code>数据页</code> 和 <code>内存缓冲池</code> 中的 <code>页</code> 是不同步的，对于 <code>内存缓冲池</code> 中页的修改，先写入重做日志文件，再写入磁盘，因此是一种异步的方式。</li></ol><h3 id="undo"><a class="anchor" href="#undo">#</a> undo</h3><p>undo 和 redo 正好相反，对 DB 进行修改时，DB 不但会产生 redo，而且还会产生一定的 undo, 即使执行的事务 / 语句失败了，或用 Rollback 回滚，就可以利用这些 undo 信息将数据回滚到修改之前的样子。<br>与 redo 不同的是，redo 存放在重做日志文件中，undo 存放在数据库内部的一个 <code>特殊段(segment)</code> 中，这称为 <code>undo(段)(undo segment)</code> ，undo 段位于 <code>共享表空间内</code> 。</p><div class="note info"><p>对于 undo 页的回收是在 <code>master thread</code> 中进行的， <code>master thread</code> 并不是每次都回收所有的 undo 页。</p></div><p>对于 <code>InnoDB存储引擎</code> ，DDL 语句都是隐式提交操作，所以需要注意 <code>TRUNCATE TABLE</code> 式 DDL 语言，是不能回滚的，而 DELETE 是 DML 语言，可以回滚。</p><h2 id="事务的隔离级别"><a class="anchor" href="#事务的隔离级别">#</a> 事务的隔离级别</h2><blockquote><ol><li>Read Uncommitted (读未提交)</li><li>Read Committed (读已提交)</li><li>Repeatable Read (可重复读)</li><li>Serializable (串行化)</li></ol></blockquote><div class="note info"><p>补充: ReadView<br>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：<br>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：</p><p>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。<br>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</p></div><h2 id="分布式事务"><a class="anchor" href="#分布式事务">#</a> 分布式事务</h2><p>InnoDB 存储引擎支持 XA 事务，通过 XA 事务可以来支持分布式事务的实现。<br>分布式事务指的是允许多个独立的事务资源 (transactional resources) 参与一个全局的事务中。<br>全局事务要求在其中所有参与的事务要么都提交，要么都回滚。在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 <code>Serialiable</code> .</p><p>分布式事务由一个或多个资源管理器 (Resource Managers)、一个事务管理器 (Transaction Manager) 和一个应用程序 (Application Program) 组成。</p><blockquote><ol><li>资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。</li><li>事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务中的所有资源管理器进行通信。</li><li>应用程序：定义事务的边界，指定全局事务中的操作。</li></ol></blockquote><p>分布式事务使用两阶段提交 (two-phase commit) 的方式。 在第一阶段，所有参与全局事务的节点都开始准备 (Prepare), 告诉事务管理器它们准备好提交了。<br>在第二阶段， <code>事务管理器</code> 告诉 <code>资源管理器</code> 执行 Rollback 还是 Commit。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。</p><div class="tags"><a href="/xz.github.io/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a> <a href="/xz.github.io/tags/DB/" rel="tag"><i class="ic i-tag"></i> DB</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-04 16:45:20" itemprop="dateModified" datetime="2022-03-04T16:45:20+08:00">2022-03-04</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/xz.github.io/images/wechatpay.jpg" alt="梦想稻草 微信支付"><p>微信支付</p></div><div><img data-src="/xz.github.io/images/alipay.jpg" alt="梦想稻草 支付宝"><p>支付宝</p></div><div><img data-src="/xz.github.io/images/paypal.jpg" alt="梦想稻草 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>梦想稻草 <i class="ic i-at"><em>@</em></i>My Blog</li><li class="link"><strong>本文链接：</strong> <a href="https://wulixzcn.github.io/xz.github.io/computer-science/db/mysql/innodb/" title="InnoDB存储引擎">https://wulixzcn.github.io/xz.github.io/computer-science/db/mysql/innodb/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/xz.github.io/computer-science/db/mysql/innodb/innodb_eng/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfdu6exj20zk0m87hw.jpg" title="InnoDB 引擎"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>InnoDB 引擎</h3></a></div><div class="item right"><a href="/xz.github.io/hello-world/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclwuom7cj20zk0m8dvn.jpg" title="后端知识点梳理"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>后端知识点梳理</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text">第一章 MySQL 体系结构和存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">定义数据库和实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">Mysql 体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E8%A1%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.</span> <span class="toc-text">MySQL 表存储引擎</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">2.</span> <span class="toc-text">第二章 InnoDB 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb-%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">InnoDB 体系架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#master-thread"><span class="toc-number">2.2.</span> <span class="toc-text">master thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">自适应哈希索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">第四章 表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">InnoDB 逻辑存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5segment"><span class="toc-number">3.1.1.</span> <span class="toc-text">段 (segment)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BAextent"><span class="toc-number">3.1.2.</span> <span class="toc-text">区 (extent)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5page-%E5%9D%97block"><span class="toc-number">3.1.3.</span> <span class="toc-text">页 (page) &#x2F; 块 (block)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C"><span class="toc-number">3.1.4.</span> <span class="toc-text">行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.2.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E5%92%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.2.</span> <span class="toc-text">约束和索引的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">视图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">第五章 索引与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#b%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">B + 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">4.2.</span> <span class="toc-text">B + 树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">辅助索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">B + 树索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-b%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">什么时候用 B + 树索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AF%BB-%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%92%8C%E9%A2%84%E8%AF%BB%E5%8F%96"><span class="toc-number">4.3.2.</span> <span class="toc-text">顺序读、随机读和预读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">辅助索引的优化使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">哈希算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">InnoDB 存储引擎中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">锁的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.2.</span> <span class="toc-text">一致性的非锁定读操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">快照读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">当前读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">锁的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="toc-number">5.3.1.</span> <span class="toc-text">丢失修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">5.3.2.</span> <span class="toc-text">读脏数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">5.3.3.</span> <span class="toc-text">不可重复读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.</span> <span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo"><span class="toc-number">6.1.1.</span> <span class="toc-text">redo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo"><span class="toc-number">6.1.2.</span> <span class="toc-text">undo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.3.</span> <span class="toc-text">分布式事务</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/xz.github.io/computer-science/db/mysql/innodb/" rel="bookmark" title="InnoDB存储引擎">InnoDB存储引擎</a></li><li><a href="/xz.github.io/computer-science/db/mongodb/mongodb/" rel="bookmark" title="MongoDB">MongoDB</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="梦想稻草" data-src="/xz.github.io/images/avatar.jpg"><p class="name" itemprop="name">梦想稻草</p><div class="description" itemprop="description">分享</div></div><nav class="state"><div class="item posts"><a href="/xz.github.io/archives/"><span class="count">12</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/xz.github.io/categories/"><span class="count">9</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/xz.github.io/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d1bGl4ekNO" title="https:&#x2F;&#x2F;github.com&#x2F;wulixzCN"><i class="ic i-github"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMTg1NjYxNTY3" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;185661567"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/xz.github.io/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/xz.github.io/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/xz.github.io/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/xz.github.io/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/xz.github.io/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/xz.github.io/computer-science/db/mysql/innodb/innodb_eng/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/xz.github.io/hello-world/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/xz.github.io/markdown/" title="Markdown Style test">Markdown Style test</a></span></li><li class="item"><div class="breadcrumb"><a href="/xz.github.io/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/computer-science/os/" title="分类于 os">os</a></div><span><a href="/xz.github.io/computer-science/os/computer_org/" title="计算机组成原理">计算机组成原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/xz.github.io/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/computer-science/db/" title="分类于 db">db</a></div><span><a href="/xz.github.io/computer-science/db/mysql/innodb/" title="InnoDB存储引擎">InnoDB存储引擎</a></span></li><li class="item"><div class="breadcrumb"><a href="/xz.github.io/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/computer-science/os/" title="分类于 os">os</a></div><span><a href="/xz.github.io/computer-science/os/build_os/" title="手写操作系统">手写操作系统</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/xz.github.io/computer-science/db/mysql/innodb/myisam_eng/" title="MyISAM 引擎">MyISAM 引擎</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/xz.github.io/computer-science/db/mysql/innodb/innodb_eng/" title="InnoDB 引擎">InnoDB 引擎</a></span></li><li class="item"><div class="breadcrumb"><a href="/xz.github.io/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/computer-science/os/" title="分类于 os">os</a></div><span><a href="/xz.github.io/computer-science/os/os_base/" title="操作系统基础">操作系统基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/xz.github.io/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/computer-science/db/" title="分类于 db">db</a></div><span><a href="/xz.github.io/computer-science/db/mongodb/mongodb/" title="MongoDB">MongoDB</a></span></li><li class="item"><div class="breadcrumb"><a href="/xz.github.io/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/computer-science/algorithm/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/computer-science/algorithm/algorithms/" title="分类于 算法题目">算法题目</a></div><span><a href="/xz.github.io/computer-science/algorithm/algorithms/algorithms/" title="算法">算法</a></span></li><li class="item"><div class="breadcrumb"><a href="/xz.github.io/categories/CS/" title="分类于 CS">CS</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/CS/DB/" title="分类于 DB">DB</a> <i class="ic i-angle-right"></i> <a href="/xz.github.io/categories/CS/DB/Mysql/" title="分类于 Mysql">Mysql</a></div><span><a href="/xz.github.io/mysql-base/" title="Mysql 基础">Mysql 基础</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">梦想稻草 @ Cloud</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">43k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">39 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/db/mysql/innodb/",favicon:{show:"wulixz",hide:"cloud"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/xz.github.io/js/app.js?v=0.2.5"></script></body></html>